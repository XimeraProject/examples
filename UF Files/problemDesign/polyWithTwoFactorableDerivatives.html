<!DOCTYPE html><html lang="en"><head> <title>Cubic with Two Factorable Derivatives</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)"/> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)"/> 
<!-- charset=utf-8,-css,html,htex4ht,xhtml --> 
<meta name="src" content="polyWithTwoFactorableDerivatives.tex"/> 
<meta name="author" content=""/> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"/> 
<meta name="ximera" content="version 0.0.1"/> 
<link href="https://xronos.clas.ufl.edu/public/v1.8.2/stylesheets/base.css" media="screen"/> 
<script type="text/javascript" async="" src="https://xronos.clas.ufl.edu/public/javascripts/standalone.min.js"></script> 
<meta name="dependency" content="e4e49ceaf8e0991422ab0c18ceddb91cbf76803a preamble.tex"/><meta name="dependency" content="731b2c9f09a6412355c1eb187bbdb9c9a3b896b4 problemDesign/polyWithTwoFactorableDerivatives.tex"/></head><body> 
<div class="preamble"><script type="math/tex">\newenvironment {prompt}{}{}
\newcommand {\ungraded }[0]{}
\newcommand {\celsius }[0]{}
\newcommand {\degree }[0]{}
\newcommand {\ohm }[0]{}
\newcommand {\log }[0]{\ln }
\newcommand {\newrobustcmd }[0]{}
\newcommand {\csshow }[1]{\begingroup \expandafter \endgroup \expandafter \show \csname #1\endcsname }
\newcommand {\csmeaning }[1]{\ifcsname #1\endcsname \expandafter \meaning \csname #1\endcsname \else \detokenize {undefined}\fi }
\newcommand {\ifdefmacro }[0]{}
\newcommand {\ifdefparam }[0]{}
\newcommand {\ifdefprotected }[0]{}
\newcommand {\ifnumequal }[1]{\ifnumcomp {#1}=}
\newcommand {\ifnumgreater }[1]{\ifnumcomp {#1}&#x003E;}
\newcommand {\ifnumless }[1]{\ifnumcomp {#1}&#x003C;}
\newcommand {\ifdimequal }[1]{\ifdimcomp {#1}=}
\newcommand {\ifdimgreater }[1]{\ifdimcomp {#1}&#x003E;}
\newcommand {\ifdimless }[1]{\ifdimcomp {#1}&#x003C;}
\newcommand {\expandonce }[1]{\unexpanded \expandafter {#1}}
\newcommand {\csexpandonce }[1]{\expandafter \expandonce \csname #1\endcsname }
\newcommand {\protecting }[0]{}
\newcommand {\csdef }[1]{\expandafter \def \csname #1\endcsname }
\newcommand {\csedef }[1]{\expandafter \edef \csname #1\endcsname }
\newcommand {\csgdef }[1]{\expandafter \gdef \csname #1\endcsname }
\newcommand {\csxdef }[1]{\expandafter \xdef \csname #1\endcsname }
\newcommand {\cslet }[2]{\expandafter \let \csname #1\endcsname #2}
\newcommand {\letcs }[2]{\ifcsdef {#2} {\expandafter \let \expandafter #1\csname #2\endcsname } {\undef #1}}
\newcommand {\csletcs }[2]{\ifcsdef {#2} {\expandafter \let \csname #1\expandafter \endcsname \csname #2\endcsname } {\csundef {#1}}}
\newcommand {\csuse }[1]{\ifcsname #1\endcsname \csname #1\expandafter \endcsname \fi }
\newcommand {\appto }[2]{\ifundef {#1} {\edef #1{\unexpanded {#2}}} {\edef #1{\expandonce #1\unexpanded {#2}}}}
\newcommand {\eappto }[2]{\ifundef {#1} {\edef #1{#2}} {\edef #1{\expandonce #1#2}}}
\newcommand {\gappto }[2]{\ifundef {#1} {\xdef #1{\unexpanded {#2}}} {\xdef #1{\expandonce #1\unexpanded {#2}}}}
\newcommand {\xappto }[2]{\ifundef {#1} {\xdef #1{#2}} {\xdef #1{\expandonce #1#2}}}
\newcommand {\preto }[2]{\ifundef {#1} {\edef #1{\unexpanded {#2}}} {\edef #1{\unexpanded {#2}\expandonce #1}}}
\newcommand {\epreto }[2]{\ifundef {#1} {\edef #1{#2}} {\edef #1{#2\expandonce #1}}}
\newcommand {\gpreto }[2]{\ifundef {#1} {\xdef #1{\unexpanded {#2}}} {\xdef #1{\unexpanded {#2}\expandonce #1}}}
\newcommand {\xpreto }[2]{\ifundef {#1} {\xdef #1{#2}} {\xdef #1{#2\expandonce #1}}}
\newcommand {\csappto }[1]{\expandafter \appto \csname #1\endcsname }
\newcommand {\cseappto }[1]{\expandafter \eappto \csname #1\endcsname }
\newcommand {\csgappto }[1]{\expandafter \gappto \csname #1\endcsname }
\newcommand {\csxappto }[1]{\expandafter \xappto \csname #1\endcsname }
\newcommand {\cspreto }[1]{\expandafter \preto \csname #1\endcsname }
\newcommand {\csepreto }[1]{\expandafter \epreto \csname #1\endcsname }
\newcommand {\csgpreto }[1]{\expandafter \gpreto \csname #1\endcsname }
\newcommand {\csxpreto }[1]{\expandafter \xpreto \csname #1\endcsname }
\newcommand {\csnumdef }[1]{\expandafter \numdef \csname #1\endcsname }
\newcommand {\csnumgdef }[1]{\expandafter \numgdef \csname #1\endcsname }
\newcommand {\csdimdef }[1]{\expandafter \dimdef \csname #1\endcsname }
\newcommand {\csdimgdef }[1]{\expandafter \dimgdef \csname #1\endcsname }
\newcommand {\csgluedef }[1]{\expandafter \gluedef \csname #1\endcsname }
\newcommand {\csgluegdef }[1]{\expandafter \gluegdef \csname #1\endcsname }
\newcommand {\mudef }[2]{\ifundef #1{\def #1{0mu}}{}\edef #1{\the \muexpr #2}}
\newcommand {\csmudef }[1]{\expandafter \mudef \csname #1\endcsname }
\newcommand {\csmugdef }[1]{\expandafter \mugdef \csname #1\endcsname }
\newcommand {\listbreak }[0]{}
\newcommand {\listadd }[2]{\ifblank {#2}{}{\appto #1{#2|}}}
\newcommand {\listgadd }[2]{\ifblank {#2}{}{\gappto #1{#2|}}}
\newcommand {\listcsadd }[1]{\expandafter \listadd \csname #1\endcsname }
\newcommand {\listcseadd }[1]{\expandafter \listeadd \csname #1\endcsname }
\newcommand {\listcsgadd }[1]{\expandafter \listgadd \csname #1\endcsname }
\newcommand {\listcsxadd }[1]{\expandafter \listxadd \csname #1\endcsname }
\newcommand {\listcsremove }[1]{\expandafter \listremove \csname #1\endcsname }
\newcommand {\listcsgremove }[1]{\expandafter \listgremove \csname #1\endcsname }
\newcommand {\dolistloop }[0]{\forlistloop \do }
\newcommand {\dolistcsloop }[0]{\forlistcsloop \do }
\newcommand {\AfterPreamble }[0]{\AtBeginDocument }
\newcommand {\mathtoolsset }[1]{\setkeys {\MT_options_name: }{#1}}
\newcommand {\refeq }[1]{\textup {\ref {#1}}}
\newcommand {\lparen }[0]{(}
\newcommand {\rparen }[0]{)}
\newcommand {\ordinarycolon }[0]{:}
\newcommand {\MT_test_for_tcb_other:nnnnn }[1]{\MH_if:w t#1\relax \expandafter \MH_use_choice_i:nnnn \MH_else: \MH_if:w c#1\relax \expandafter \expandafter \expandafter \MH_use_choice_ii:nnnn \MH_else: \MH_if:w b#1\relax \expandafter \expandafter \expandafter \expandafter \expandafter \expandafter \expandafter \MH_use_choice_iii:nnnn \MH_else: \expandafter \expandafter \expandafter \expandafter \expandafter \expandafter \expandafter \MH_use_choice_iv:nnnn \MH_fi: \MH_fi: \MH_fi: }
\newcommand {\newcases }[6]{\newenvironment {#1}{\MT_start_cases:nnnn {#2}{#3}{#4}{#5}}{\MH_end_cases: \right #6}}
\newcommand {\renewcases }[6]{\renewenvironment {#1}{\MT_start_cases:nnnn {#2}{#3}{#4}{#5}}{\MH_end_cases: \right #6}}
\newcommand {\SwapAboveDisplaySkip }[0]{\noalign {\vskip -\abovedisplayskip \vskip \abovedisplayshortskip }}
\newcommand {\vdotswithin }[1]{{\mathmakebox [\widthof {\ensuremath {{}#1{}}}][c]{{\vdots }}}}
\newcommand {\MTFlushSpaceBelow }[0]{\\\noalign {\nobreak \vskip -\lineskip \vskip -\l_MT_shortvdotswithinadjustbelow_dim \vskip -\origjot \vskip \jot }}
\newcommand {\mathmbox }[0]{\mathpalette \MT_mathmbox:nn }
\newcommand {\crampedsubstack }[1]{\crampedsubarray {c}#1\endcrampedsubarray }
\newcommand {\prescript  }[3]{\mathchoice {\MT_prescript_inner: {#1}{#2}{#3}{\scriptstyle }}{\MT_prescript_inner: {#1}{#2}{#3}{\scriptstyle }}{\MT_prescript_inner: {#1}{#2}{#3}{\scriptscriptstyle }}{\MT_prescript_inner: {#1}{#2}{#3}{\scriptscriptstyle }}}
\newcommand {\spreadlines }[1]{\setlength {\jot }{#1}\ignorespaces }
\newcommand {\newgathered }[4]{\newenvironment {#1}{\def \MT_gathered_pre: {#2}\def \MT_gathered_post: {#3}\def \MT_gathered_env_end: {#4}\MT_gathered_env }{\endMT_gathered_env }}
\newcommand {\renewgathered }[4]{\renewenvironment {#1}{\def \MT_gathered_pre: {#2}\def \MT_gathered_post: {#3}\def \MT_gathered_env_end: {#4}\MT_gathered_env }{\endMT_gathered_env }}
\newcommand {\lgathered }[0]{\def \MT_gathered_pre: {}\def \MT_gathered_post: {\hfil }\def \MT_gathered_env_end: {}\MT_gathered_env }
\newcommand {\rgathered }[0]{\def \MT_gathered_pre: {\hfil }\def \MT_gathered_post: {}\def \MT_gathered_env_end: {}\MT_gathered_env }
\newcommand {\gathered }[0]{\def \MT_gathered_pre: {\hfil }\def \MT_gathered_post: {\hfil }\def \MT_gathered_env_end: {}\MT_gathered_env }
\newcommand {\splitfrac }[2]{\genfrac {}{}{0pt}{1}{\textstyle #1\quad \hfill }{\textstyle \hfill \quad \mathstrut #2}}
\newcommand {\splitdfrac }[2]{\genfrac {}{}{0pt}{0}{#1\quad \hfill }{\hfill \quad \mathstrut #2}}
\newcommand {\?\c__siunitx_minus_tl }[0]{\UseTextSymbol {TS1}\c__siunitx_minus_tl }
\newcommand {\?\c__siunitx_mu_tl }[0]{\UseTextSymbol {TS1}\c__siunitx_mu_tl }
\newcommand {\tabitem }[0]{\makebox [1em][r]{\textbullet ~}}
\newcommand {\letterPlus }[0]{\makebox [0pt][l]{$+$}}
\newcommand {\letterMinus }[0]{\makebox [0pt][l]{$-$}}
\newcommand {\texttt }[1]{#1}
\newcommand {\HyperFirstAtBeginDocument }[0]{\AtBeginDocument }
\newcommand {\degree }[0]{\ensuremath {^\circ }}
\newcommand {\celsius  }[0]{\ifmmode ^\circ \mathrm {C}\else $^\circ $C\fi }
\newcommand {\ohm  }[0]{\ifmmode \Omega \else $\Omega $\fi }
\newcommand {\dblcolon }[0]{\vcentcolon \mathrel {\mkern -.9mu}\vcentcolon }
\newcommand {\coloneqq }[0]{\vcentcolon \mathrel {\mkern -1.2mu}=}
\newcommand {\Coloneqq }[0]{\dblcolon \mathrel {\mkern -1.2mu}=}
\newcommand {\coloneq }[0]{\vcentcolon \mathrel {\mkern -1.2mu}\mathrel {-}}
\newcommand {\Coloneq }[0]{\dblcolon \mathrel {\mkern -1.2mu}\mathrel {-}}
\newcommand {\eqqcolon }[0]{=\mathrel {\mkern -1.2mu}\vcentcolon }
\newcommand {\Eqqcolon }[0]{=\mathrel {\mkern -1.2mu}\dblcolon }
\newcommand {\eqcolon }[0]{\mathrel {-}\mathrel {\mkern -1.2mu}\vcentcolon }
\newcommand {\Eqcolon }[0]{\mathrel {-}\mathrel {\mkern -1.2mu}\dblcolon }
\newcommand {\colonapprox }[0]{\vcentcolon \mathrel {\mkern -1.2mu}\approx }
\newcommand {\Colonapprox }[0]{\dblcolon \mathrel {\mkern -1.2mu}\approx }
\newcommand {\colonsim }[0]{\vcentcolon \mathrel {\mkern -1.2mu}\sim }
\newcommand {\Colonsim }[0]{\dblcolon \mathrel {\mkern -1.2mu}\sim }
\newcommand {\nuparrow }[0]{\MH_nuparrow: }
\newcommand {\ndownarrow }[0]{\MH_ndownarrow: }
\newcommand {\bigtimes }[0]{\MH_csym_bigtimes: }</script><script type="text/javascript"> 
</script> 
</div>
                                                                                                     
   <div class="abstract">
<!--l. 9--><p class="indent">   Generic testing link.
</p></div>   <div class="maketitle"></div>
<script type="text/sagemath">def RandInt(a,b):
    """ Returns a random integer in [`a`,`b`]. Note that `a` and `b` should be integers themselves to avoid unexpected behavior.
    """
    return QQ(randint(int(a),int(b)))
    # return choice(range(a,b+1))

def NonZeroInt(b,c, avoid = [0]):
    """ Returns a random integer in [`b`,`c`] which is not in `av`.
        If `av` is not specified, defaults to a non-zero integer.
    """
    while True:
        a = RandInt(b,c)
        if a not in avoid:
            return a



## Start with a while loop to make sure the result has reasonable coefficients, at least in general size.
p1f2 = 9999*x^3 + 9999*x^2 + 9999*x + 9999

while ((abs(p1f2.coefficient(x^3))>100) or (abs(p1f2.coefficient(x^2))>100) or (abs(p1f2.coefficient(x))>100) or (abs(p1f2(x=0))>100)):
    ### We start by taking a product of factors to get a factorable first derivative.

    # Make sure the leading coefficient is divisible by 3, which will help ensure the numbers stay nice(ish) after integrating.
    p1c1 = 1
    p1c3 = 1
    while mod(p1c1*p1c3,3)>0:
        p1c1 = NonZeroInt(-5,5)
        p1c2 = NonZeroInt(-5,5)
        p1c3 = RandInt(1,6)
        p1c4 = -sign(p1c1)*sign(p1c2)*RandInt(1,5)# Rigged sign to make sure we get a difference of squares in the cube, not sum.


    p1fact1 = p1c1*x-p1c2
    p1fact2 = p1c3*x-p1c4

    p1f1 = expand(p1fact1*p1fact2)


                                                                                                     
                                                                                                     

    ### Now we make the original function by integrating, then finding an appropriate C to add to make it factor by grouping in some nice way.

    p1f2temp = integral(p1f1,x)

    # Now, we assume we are going to factor by grouping, to be kind, so we extract the necessary constant we will need:
    p1c5 = p1f2temp.coefficient(x^2)*p1f2temp.coefficient(x)/p1f2temp.coefficient(x^3)

    p1f2 = p1f2temp+p1c5

    if p1f2.coefficient(x^3)*p1f2.coefficient(x)<0:
        p1sqrtval = p1f2.coefficient(x)/p1f2.coefficient(x^3)
        p1f2fact1a = x - sqrt(abs(p1sqrtval))
        p1f2fact1b = x + sqrt(abs(p1sqrtval))
        p1f2fact1 = -sign(p1sqrtval)*(p1f2fact1a)*(p1f2fact1b)#(-sqrt(-p1f2.coefficient(x^3))*x + sqrt(p1f2.coefficient(x)))*(sqrt(-p1f2.coefficient(x^3))*x + sqrt(p1f2.coefficient(x)) )
        p1f2fact2 = p1f2.coefficient(x^3)*x + p1f2.coefficient(x^2)
        p1f1zero1 = -p1f2fact1a(x=0)/p1f2fact1a.coefficient(x)
        p1f1zero2 = -p1f2fact1b(x=0)/p1f2fact1b.coefficient(x)
        p1f1zero3 = -p1f2fact2(x=0)/p1f2fact2.coefficient(x)
    else:
        p1f2fact1 = p1f2.coefficient(x^3)*x^2 + p1f2.coefficient(x)
        p1f2fact2 = x + p1f2.coefficient(x^2)/p1f2.coefficient(x^3)
        p1f1zero1 = 0
        p1f1zero2 = 0
        p1f1zero3 = -p1f2fact2(x=0)/p1f2fact2.coefficient(x)

    p1f2check = expand(p1f2fact1*p1f2fact2)




    ### To get the second derivative function we can take the derivative of the original - which must be linear and so we know it is easy to solve for students.

    p1f3 = derivative(p1f1,x)



</script>
<h3 class="likesectionHead"><a id="x1-1000"></a>The Problem</h3>
<!--l. 96--><p class="noindent">Often we want to have a polynomial whose first and second derivative are suitably “nice” for students in order to allow them to
                                                                                                     
                                                                                                     
factor the polynomial itself, as well as its first and second derivatives, in order to find zeros for things like graphing.
Unfortunately, it turns out, that creating a polynomial that is factorable, and whose first and second derivative are also
factorable, is a <em>highly</em> nontrivial problem. Here we provide code that works (and generates <em>relatively</em> nice polynomials as
well) to generate such a polynomial that is a cubic function (this also helps avoid requiring something like the
rational root theorem for factoring the original polynomial - in this case the cubic is always factorable by grouping as
well).
</p>
<h3 class="likesectionHead"><a id="x1-2000"></a>The Result</h3>
<!--l. 102--><p class="noindent">The original functions is <script type="math/tex">f(x) = \sage {p1f2} </script> which should factor into: <script type="math/tex; mode=display">\sage {p1f2fact1}\left (\sage {p1f2fact2}\right )</script>
</p><!--l. 106--><p class="indent">   The first derivative is <script type="math/tex">f'(x) = \sage {p1f1}</script> which should factor into <script type="math/tex; mode=display">\left (\sage {p1fact1}\right )\cdot \left (\sage {p1fact2}\right )</script>
</p><!--l. 110--><p class="indent">   The second derivative is <script type="math/tex">f''(x) = \sage {p1f3}</script> which is linear so it factors trivially (Yes, we kind of cheat here).
</p>
<h3 class="likesectionHead"><a id="x1-3000"></a>The Magic</h3>
<!--l. 122--><p class="noindent">Here is the sagecode that generates the above problem:
</p><!--l. 124--><p class="indent">   </p><pre>\begin{sagesilent}
 <br/>def RandInt(a,b):
 <br/>    &#34;&#34;&#34; Returns a random integer in [‘a‘,‘b‘]. Note that ‘a‘ and ‘b‘ should be integers themselves to avoid unexpected behavior.
 <br/>    &#34;&#34;&#34;
 <br/>    return QQ(randint(int(a),int(b)))
 <br/>    # return choice(range(a,b+1))
 <br/>
 <br/>def NonZeroInt(b,c, avoid = [0]):
 <br/>    &#34;&#34;&#34; Returns a random integer in [‘b‘,‘c‘] which is not in ‘av‘.
 <br/>        If ‘av‘ is not specified, defaults to a non-zero integer.
 <br/>    &#34;&#34;&#34;
 <br/>    while True:
 <br/>        a = RandInt(b,c)
 <br/>        if a not in avoid:
 <br/>            return a
 <br/>
 <br/>
 <br/>
 <br/>## Start with a while loop to make sure the result has reasonable coefficients, at least in general size.
 <br/>p1f2 = 9999*x^3 + 9999*x^2 + 9999*x + 9999
 <br/>
 <br/>while ((abs(p1f2.coefficient(x^3))&gt;100) or (abs(p1f2.coefficient(x^2))&gt;100) or (abs(p1f2.coefficient(x))&gt;100) or (abs(p1f2(x=0))&gt;100)):
 <br/>    ### We start by taking a product of factors to get a factorable first derivative.
 <br/>
 <br/>    # Make sure the leading coefficient is divisible by 3, which will help ensure the numbers stay nice(ish) after integrating.
 <br/>    p1c1 = 1
 <br/>    p1c3 = 1
 <br/>    while mod(p1c1*p1c3,3)&gt;0:
 <br/>        p1c1 = NonZeroInt(-5,5)
 <br/>        p1c2 = NonZeroInt(-5,5)
 <br/>        p1c3 = RandInt(1,6)
 <br/>        p1c4 = -sign(p1c1)*sign(p1c2)*RandInt(1,5)# Rigged sign to make sure we get a difference of squares in the cube, not sum.
 <br/>
 <br/>
 <br/>    p1fact1 = p1c1*x-p1c2
 <br/>    p1fact2 = p1c3*x-p1c4
                                                                                                     
                                                                                                     
 <br/>
 <br/>    p1f1 = expand(p1fact1*p1fact2)
 <br/>
 <br/>
 <br/>
 <br/>    ### Now we make the original function by integrating, then finding an appropriate ‘‘C’’ to add to make it factor by grouping in some nice way.
 <br/>
 <br/>    p1f2temp = integral(p1f1,x)
 <br/>
 <br/>    # Now, we assume we are going to factor by grouping, to be kind, so we extract the necessary constant we will need:
 <br/>    p1c5 = p1f2temp.coefficient(x^2)*p1f2temp.coefficient(x)/p1f2temp.coefficient(x^3)
 <br/>
 <br/>    p1f2 = p1f2temp+p1c5
 <br/>
 <br/>    if p1f2.coefficient(x^3)*p1f2.coefficient(x)&lt;0:
 <br/>        p1sqrtval = p1f2.coefficient(x)/p1f2.coefficient(x^3)
 <br/>        p1f2fact1a = x - sqrt(abs(p1sqrtval))
 <br/>        p1f2fact1b = x + sqrt(abs(p1sqrtval))
 <br/>        p1f2fact1 = -sign(p1sqrtval)*(p1f2fact1a)*(p1f2fact1b)#(-sqrt(-p1f2.coefficient(x^3))*x + sqrt(p1f2.coefficient(x)))*(sqrt(-p1f2.coefficient(x^3))*x + sqrt(p1f2.coefficient(x)) )
 <br/>        p1f2fact2 = p1f2.coefficient(x^3)*x + p1f2.coefficient(x^2)
 <br/>        p1f1zero1 = -p1f2fact1a(x=0)/p1f2fact1a.coefficient(x)
 <br/>        p1f1zero2 = -p1f2fact1b(x=0)/p1f2fact1b.coefficient(x)
 <br/>        p1f1zero3 = -p1f2fact2(x=0)/p1f2fact2.coefficient(x)
 <br/>    else:
 <br/>        p1f2fact1 = p1f2.coefficient(x^3)*x^2 + p1f2.coefficient(x)
 <br/>        p1f2fact2 = x + p1f2.coefficient(x^2)/p1f2.coefficient(x^3)
 <br/>        p1f1zero1 = 0
 <br/>        p1f1zero2 = 0
 <br/>        p1f1zero3 = -p1f2fact2(x=0)/p1f2fact2.coefficient(x)
 <br/>
 <br/>    p1f2check = expand(p1f2fact1*p1f2fact2)
 <br/>
 <br/>
 <br/>
 <br/>
 <br/>    ### To get the second derivative function we can take the derivative of the original - which must be linear and so we know it is easy to solve for students.
 <br/>
 <br/>    p1f3 = derivative(p1f1,x)
 <br/>
 <br/>\end{sagesilent}
 <br/>
<!--l. 202--></pre>
    
 

                                                                                                     
                                                                                                     
                                                                                                     


</body></html>